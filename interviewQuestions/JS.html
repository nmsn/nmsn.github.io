<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS | NMSN</title>
    <meta name="generator" content="VuePress 1.5.4">
    <link rel="icon" href="/favicon.ico">
    <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?6594ba1364804631f0a8fd4452766fed";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
    <script aysnc="true" src="https://www.googletagmanager.com/gtag/js?id=UA-127895888-1"></script>
    <script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-127895888-1');
  </script>
    <meta name="description" content="Somebody has to win, so why not be me?">
    <link rel="preload" href="/assets/css/0.styles.8eb54cf4.css" as="style"><link rel="preload" href="/assets/js/app.139693ee.js" as="script"><link rel="preload" href="/assets/js/2.4a609977.js" as="script"><link rel="preload" href="/assets/js/8.6f768000.js" as="script"><link rel="prefetch" href="/assets/js/10.1508431a.js"><link rel="prefetch" href="/assets/js/11.a8d4d8de.js"><link rel="prefetch" href="/assets/js/12.64b146dd.js"><link rel="prefetch" href="/assets/js/13.c768d2ed.js"><link rel="prefetch" href="/assets/js/14.6ba75e19.js"><link rel="prefetch" href="/assets/js/15.3d38a3dd.js"><link rel="prefetch" href="/assets/js/16.3b71c3d4.js"><link rel="prefetch" href="/assets/js/17.bfdcdb09.js"><link rel="prefetch" href="/assets/js/18.d51a683e.js"><link rel="prefetch" href="/assets/js/19.23df3402.js"><link rel="prefetch" href="/assets/js/20.18bff528.js"><link rel="prefetch" href="/assets/js/21.5f084c8f.js"><link rel="prefetch" href="/assets/js/22.83d56967.js"><link rel="prefetch" href="/assets/js/23.1ca87db8.js"><link rel="prefetch" href="/assets/js/24.a5ed989e.js"><link rel="prefetch" href="/assets/js/25.c205d178.js"><link rel="prefetch" href="/assets/js/26.bc66ddb7.js"><link rel="prefetch" href="/assets/js/27.a203ad60.js"><link rel="prefetch" href="/assets/js/28.a5fddc03.js"><link rel="prefetch" href="/assets/js/29.b8135a81.js"><link rel="prefetch" href="/assets/js/3.92f844fc.js"><link rel="prefetch" href="/assets/js/30.8e3f504e.js"><link rel="prefetch" href="/assets/js/31.1a40ce54.js"><link rel="prefetch" href="/assets/js/32.3182375a.js"><link rel="prefetch" href="/assets/js/33.9035e369.js"><link rel="prefetch" href="/assets/js/34.c88060a1.js"><link rel="prefetch" href="/assets/js/35.ebe94d64.js"><link rel="prefetch" href="/assets/js/36.f2c55ad2.js"><link rel="prefetch" href="/assets/js/37.dcba3dac.js"><link rel="prefetch" href="/assets/js/38.702fee13.js"><link rel="prefetch" href="/assets/js/39.bd6dcc51.js"><link rel="prefetch" href="/assets/js/4.a5e6f7c3.js"><link rel="prefetch" href="/assets/js/40.d3bb0c9e.js"><link rel="prefetch" href="/assets/js/41.cde4c57a.js"><link rel="prefetch" href="/assets/js/42.0de83a4e.js"><link rel="prefetch" href="/assets/js/43.e1b7b0a2.js"><link rel="prefetch" href="/assets/js/44.427f477d.js"><link rel="prefetch" href="/assets/js/45.58ee4553.js"><link rel="prefetch" href="/assets/js/46.7939ee37.js"><link rel="prefetch" href="/assets/js/47.5fdb4957.js"><link rel="prefetch" href="/assets/js/48.eafd4d23.js"><link rel="prefetch" href="/assets/js/49.c5fde335.js"><link rel="prefetch" href="/assets/js/5.d1ebbe8e.js"><link rel="prefetch" href="/assets/js/50.02dfe76e.js"><link rel="prefetch" href="/assets/js/51.cebce812.js"><link rel="prefetch" href="/assets/js/52.d2188264.js"><link rel="prefetch" href="/assets/js/53.187a5597.js"><link rel="prefetch" href="/assets/js/54.e3d736d5.js"><link rel="prefetch" href="/assets/js/55.e8266192.js"><link rel="prefetch" href="/assets/js/56.525a30bb.js"><link rel="prefetch" href="/assets/js/57.53d73e65.js"><link rel="prefetch" href="/assets/js/58.0779ff8b.js"><link rel="prefetch" href="/assets/js/6.442a394c.js"><link rel="prefetch" href="/assets/js/7.16e79d1e.js"><link rel="prefetch" href="/assets/js/9.05ee9782.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8eb54cf4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">NMSN</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/tech/" class="nav-link">
  快查总结
</a></div><div class="nav-item"><a href="/excerpt/" class="nav-link">
  摘录
</a></div><div class="nav-item"><a href="/interviewQuestions/" class="nav-link router-link-active">
  面试题
</a></div><div class="nav-item"><a href="/readingNotes/" class="nav-link">
  读书笔记
</a></div><div class="nav-item"><a href="/work/" class="nav-link">
  工作总结
</a></div> <a href="https://github.com/nmsn" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/tech/" class="nav-link">
  快查总结
</a></div><div class="nav-item"><a href="/excerpt/" class="nav-link">
  摘录
</a></div><div class="nav-item"><a href="/interviewQuestions/" class="nav-link router-link-active">
  面试题
</a></div><div class="nav-item"><a href="/readingNotes/" class="nav-link">
  读书笔记
</a></div><div class="nav-item"><a href="/work/" class="nav-link">
  工作总结
</a></div> <a href="https://github.com/nmsn" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>面试题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interviewQuestions/HTML.html" class="sidebar-link">HTML</a></li><li><a href="/interviewQuestions/CSS.html" class="sidebar-link">CSS</a></li><li><a href="/interviewQuestions/JS.html" aria-current="page" class="active sidebar-link">JS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interviewQuestions/JS.html#原型与原型链" class="sidebar-link">原型与原型链</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/JS.html#this绑定的4种形式" class="sidebar-link">this绑定的4种形式</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/JS.html#执行上线文和作用域链" class="sidebar-link">执行上线文和作用域链</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/JS.html#防抖与节流" class="sidebar-link">防抖与节流</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/JS.html#深克隆" class="sidebar-link">深克隆</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/JS.html#实现订阅发布模式" class="sidebar-link">实现订阅发布模式</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/JS.html#实现promise" class="sidebar-link">实现Promise</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/JS.html#内存管理" class="sidebar-link">内存管理</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/JS.html#前端路由的实现" class="sidebar-link">前端路由的实现</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/JS.html#offset-client-scroll" class="sidebar-link">offset/client/scroll</a></li><li class="sidebar-sub-header"><a href="/interviewQuestions/JS.html#立即调用函数表达式-iife-立即执行函数" class="sidebar-link">立即调用函数表达式（IIFE）/立即执行函数</a></li></ul></li><li><a href="/interviewQuestions/Network.html" class="sidebar-link">网络</a></li><li><a href="/interviewQuestions/浏览器.html" class="sidebar-link">浏览器</a></li><li><a href="/interviewQuestions/React.html" class="sidebar-link">React</a></li><li><a href="/interviewQuestions/Vue.html" class="sidebar-link">Vue</a></li><li><a href="/interviewQuestions/TypeScript.html" class="sidebar-link">TypeScript</a></li><li><a href="/interviewQuestions/Webpack.html" class="sidebar-link">Webpack</a></li><li><a href="/interviewQuestions/设计模式.html" class="sidebar-link">设计模式</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="js"><a href="#js" class="header-anchor">#</a> JS</h1> <h2 id="原型与原型链"><a href="#原型与原型链" class="header-anchor">#</a> 原型与原型链</h2> <blockquote><p>JavaScript 常被描述为一种基于原型的语言 (prototype-based language)——每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。</p></blockquote> <h3 id="原型对象"><a href="#原型对象" class="header-anchor">#</a> 原型对象</h3> <p>绝大部分的函数(少数内建函数除外)都有一个prototype属性,这个属性是原型对象用来创建新对象实例,而所有被创建的对象都会共享原型对象,因此这些对象便可以访问原型对象的属性。</p> <h3 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h3> <p>原因是每个对象都有<code>__proto__</code>属性，此属性指向该对象的构造函数的原型。</p> <p>对象可以通过<code>__proto__</code>与上游的构造函数的原型对象连接起来，而上游的原型对象也有一个<code>__proto__</code>，这样就形成了原型链。</p> <p><img src="/assets/img/prototype.bc2193ab.jpg" alt="prototype"></p> <h2 id="this绑定的4种形式"><a href="#this绑定的4种形式" class="header-anchor">#</a> this绑定的4种形式</h2> <h3 id="_1-默认绑定"><a href="#_1-默认绑定" class="header-anchor">#</a> 1. 默认绑定</h3> <ul><li>独立函数调用，可以把默认绑定看作是无法应用其他规则时的默认规则，this指向全局对象</li> <li>严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined，只有函数运行在非严格模式下，默认绑定才能绑定到全局对象。
在严格模式下调用函数则不影响默认绑定。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 运行在严格模式下，this会绑定到undefined</span>
  <span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token comment">// 调用</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TypeError: Cannot read property 'a' of undefined</span>

<span class="token comment">// --------------------------------------</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 运行</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 严格模式下调用函数则不影响默认绑定</span>
  <span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_2-隐式绑定"><a href="#_2-隐式绑定" class="header-anchor">#</a> 2. 隐式绑定</h3> <ul><li>当函数引用有上下文对象时，隐式绑定规则会把函数种的this绑定到这个上下文对象。
对象属性引用链中只有上一层或者说最后一层在调用中起作用。</li> <li>被隐式绑定的函数特定情况下会丢失绑定对象，应用默认绑定，把this绑定到全局对象或者undefined上。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  foo<span class="token operator">:</span> foo<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>

<span class="token comment">// 虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身。</span>
<span class="token comment">// bar()是一个不带任何修饰的函数调用，应用默认绑定。</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  foo<span class="token operator">:</span> foo<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> bar <span class="token operator">=</span> obj<span class="token punctuation">.</span>foo<span class="token punctuation">;</span> <span class="token comment">// 函数别名</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;oops, global&quot;</span><span class="token punctuation">;</span> <span class="token comment">// a是全局对象的属性</span>

<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;oops, global&quot;</span>
</code></pre></div><h3 id="_3-显式绑定"><a href="#_3-显式绑定" class="header-anchor">#</a> 3. 显式绑定</h3> <ul><li>通过call或者apply方法。第一个参数是一个对象，在底用函数时将这个对象绑定到this。因为直接指定this的绑定对象，称之为显式绑定。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2  调用foo时强制把foo的this绑定到obj上</span>


<span class="token comment">// 显式绑定无法解决丢失绑定的问题</span>
<span class="token comment">// 解决办法1.硬绑定</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> <span class="token function-variable function">bar</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span> bar<span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>

<span class="token comment">// 硬绑定的bar不可能再修改它的this</span>
<span class="token function">bar</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> window <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>

<span class="token comment">// 解决办法2.API调用的“上下文”</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> el<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    id<span class="token operator">:</span> <span class="token string">&quot;awesome&quot;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> myArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token comment">// 调用foo(..)时把this绑定到obj</span>
myArray<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> foo<span class="token punctuation">,</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 1 awesome 2 awesome 3 awesome</span>
</code></pre></div><h3 id="_4-new绑定"><a href="#_4-new绑定" class="header-anchor">#</a> 4. new绑定</h3> <ul><li>在js中，构造函数只是使用new操作符时被调用的普通函数，他们不属于某个类，也不会实例化一个类。</li> <li>包括内置对象函数（比如Number）在内的所有函数都可以用new来调用，这种函数调用被称为构造函数调用。</li> <li>实际上并不存在所谓的“构造函数”,只是对于函数的“构造调用”。</li></ul> <h4 id="new实现"><a href="#new实现" class="header-anchor">#</a> new实现</h4> <p>使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p> <ol><li>创建（或者说构造）一个新对象。</li> <li>这个新对象会被执行[[Prototype]]连接。</li> <li>这个新对象会绑定到函数调用的this。</li> <li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建一个空的对象</span>
  <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">// 获得构造函数，arguments中去除第一个参数，即构造函数</span>
    Constructor <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 链接到原型，obj 可以访问到构造函数原型中的属性</span>
  obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> <span class="token class-name">Constructor</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
  <span class="token comment">// 绑定 this 实现继承，obj 可以访问到构造函数中的属性</span>
  <span class="token keyword">var</span> ret <span class="token operator">=</span> <span class="token function">Constructor</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 优先返回构造函数返回的对象</span>
  <span class="token keyword">return</span> ret <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> ret <span class="token operator">:</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>

    <span class="token comment">// 如果构造函数有返回值且为对象，则返回该对象 ret</span>
    <span class="token comment">// return {</span>
    <span class="token comment">//     name: name,</span>
    <span class="token comment">//     age: '25'</span>
    <span class="token comment">// }</span>

    <span class="token comment">// 如果构造函数有返回值不是对象，则返回 obj</span>
    <span class="token comment">// return 'Tom is a 18 boy';</span>
<span class="token punctuation">}</span>

<span class="token comment">// 用来替代 new Person('Tom', '18')</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span>Person<span class="token punctuation">,</span> <span class="token string">'Tom'</span><span class="token punctuation">,</span> <span class="token string">'18'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="执行上线文和作用域链"><a href="#执行上线文和作用域链" class="header-anchor">#</a> 执行上线文和作用域链</h2> <p>JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段<strong>作用域</strong>规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，<strong>执行上下文</strong>在这个阶段创建。</p> <h3 id="执行上下文"><a href="#执行上下文" class="header-anchor">#</a> 执行上下文</h3> <p>函数每调用一次，都会产生一个新的执行上下文环境。因为不同的调用可能就有不同的参数。</p> <h4 id="执行上下文栈"><a href="#执行上下文栈" class="header-anchor">#</a> 执行上下文栈</h4> <p>执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除（当然了闭包并不会乖乖就范），处于活动状态的执行上下文环境只有一个。</p> <p>既然调用一个函数时一个新的执行上下文会被创建。那执行上下文的生命周期同样可以分为两个阶段。</p> <ul><li><p>创建阶段</p> <p>在这个阶段中，执行上下文会分别创建</p> <ul><li>变量对象(Variable object，VO)</li> <li>建立作用域链(Scope chain)</li> <li>确定this的指向</li></ul></li> <li><p>代码执行阶段</p> <p>在此阶段，js引擎会重扫一遍函数，用具体的变量的值来更新可变对象，并执行代码内容。</p></li></ul> <h4 id="变量对象"><a href="#变量对象" class="header-anchor">#</a> 变量对象</h4> <p>在函数上下文中，我们用活动对象(Activation object, AO)来表示变量对象(Variable object，VO)。</p> <p>活动对象其实就是被激活的变量对象，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object，而只有活动对象上的各种属性才能被访问。</p> <p>变量对象会包括：</p> <ol><li><p>语言内置</p> <ul><li>this</li> <li>arguments</li></ul></li> <li><p>函数的所有形参 (如果是函数上下文)</p> <ul><li>由名称和对应值组成的一个变量对象的属性被创建</li> <li>没有实参，属性值设为 undefined</li></ul></li> <li><p>函数声明</p> <ul><li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li> <li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li></ul></li> <li><p>变量声明</p> <ul><li>由名称和对应值（undefined）组成一个变量对象的属性被创建；</li> <li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</li></ul></li></ol> <h3 id="作用域"><a href="#作用域" class="header-anchor">#</a> 作用域</h3> <p>作用域(scope chain)是每一个执行上下文自身持有的活动对象的集合，如在本执行上下文中声明的变量和函数以及方法参数传入的对象。</p> <p>每一个执行上下文可以访问的对象包括自身的作用域和父执行上下文的作用域和父父执行上下文作用域直到全局作用域，这就产生了作用域链。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。</p> <p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。
JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</p> <p>作用域只是一个“地盘”，其中没有变量。变量是通过作用域对应的执行上下文环境中的变量对象来实现的。所以作用域是静态观念的，而执行上下文环境是动态上的，两者并不一样。有闭包存在时，一个作用域存在两个上下文环境也是有的。也就是说，作用域只是用于划分你在这个作用域里面定义的变量的有效范围，出了这个作用域就无效。</p> <p>同一个作用域下，对同一个函数的不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值，所以，作用域中变量的值是在执行过程中确定的，而作用域是在函数创建时就确定的。</p> <p>如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中找到变量的值。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">function</span> <span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span>
    <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//====&gt;  1</span>
</code></pre></div><h4 id="自由变量"><a href="#自由变量" class="header-anchor">#</a> 自由变量</h4> <p>函数在定义的时候（不是调用的时候）就已经确定了函数体内部自由变量的作用域。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">100</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">20</span>
  <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token comment">// a是在fn作用域使用，但是并没有在fn作用域定义，这就是自由变量。</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> bar
<span class="token punctuation">}</span>

<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">200</span>
<span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>bar要取得a的值，就要到创建bar这个函数的作用域中取值（这里是fn作用域），fn作用域也没有a，就到创建fn这个函数的作用域中取值（这里是全局作用域），找到了就结束了。这就是作用域链。</p> <h4 id="作用域链"><a href="#作用域链" class="header-anchor">#</a> 作用域链</h4> <p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p> <p>其本质是JavaScript在执行过程中会创造可执行上下文，可执行上下文中的词法环境中含有外部词法环境的引用，我们可以通过这个引用获取外部词法环境的变量、声明等，这些引用串联起来一直指向全局的词法环境，因此形成了作用域链。</p> <h2 id="防抖与节流"><a href="#防抖与节流" class="header-anchor">#</a> 防抖与节流</h2> <h3 id="防抖-debounce"><a href="#防抖-debounce" class="header-anchor">#</a> 防抖（debounce）</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 防抖函数</span>
<span class="token keyword">const</span> <span class="token function-variable function">debounce</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>使用场景</p> <ul><li>按钮提交场景：防止多次提交按钮，只执行最后提交的一次</li> <li>服务端验证场景：表单验证需要服务端配合，只执行一段连续的输入事件的最后一次，还有搜索联想词功能类似</li></ul> <h3 id="节流-throttle"><a href="#节流-throttle" class="header-anchor">#</a> 节流（throttle）</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">throttle</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> prev <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> now <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> prev <span class="token operator">&gt;=</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
            prev <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用场景</p> <ul><li>拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动</li> <li>缩放场景：监控浏览器resize</li> <li>动画场景：避免短时间内多次触发动画引起性能问题</li></ul> <h2 id="深克隆"><a href="#深克隆" class="header-anchor">#</a> 深克隆</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * deep clone
 * @param  {[type]} parent object 需要进行克隆的对象
 * @return {[type]}        深克隆后的对象
 */</span>
<span class="token keyword">const</span> <span class="token function-variable function">clone</span> <span class="token operator">=</span> <span class="token parameter">parent</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 判断类型</span>
  <span class="token keyword">const</span> <span class="token function-variable function">isType</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> type</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">&quot;object&quot;</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> typeString <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> flag<span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token string">&quot;Array&quot;</span><span class="token operator">:</span>
        flag <span class="token operator">=</span> typeString <span class="token operator">===</span> <span class="token string">&quot;[object Array]&quot;</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token keyword">case</span> <span class="token string">&quot;Date&quot;</span><span class="token operator">:</span>
        flag <span class="token operator">=</span> typeString <span class="token operator">===</span> <span class="token string">&quot;[object Date]&quot;</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token keyword">case</span> <span class="token string">&quot;RegExp&quot;</span><span class="token operator">:</span>
        flag <span class="token operator">=</span> typeString <span class="token operator">===</span> <span class="token string">&quot;[object RegExp]&quot;</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token keyword">default</span><span class="token operator">:</span>
        flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> flag<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">// 处理正则</span>
  <span class="token keyword">const</span> <span class="token function-variable function">getRegExp</span> <span class="token operator">=</span> <span class="token parameter">re</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> flags <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>re<span class="token punctuation">.</span>global<span class="token punctuation">)</span> flags <span class="token operator">+=</span> <span class="token string">&quot;g&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>re<span class="token punctuation">.</span>ignoreCase<span class="token punctuation">)</span> flags <span class="token operator">+=</span> <span class="token string">&quot;i&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>re<span class="token punctuation">.</span>multiline<span class="token punctuation">)</span> flags <span class="token operator">+=</span> <span class="token string">&quot;m&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> flags<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 维护两个储存循环引用的数组</span>
  <span class="token keyword">const</span> parents <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token function-variable function">_clone</span> <span class="token operator">=</span> <span class="token parameter">parent</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> parent <span class="token operator">!==</span> <span class="token string">&quot;object&quot;</span><span class="token punctuation">)</span> <span class="token keyword">return</span> parent<span class="token punctuation">;</span>

    <span class="token keyword">let</span> child<span class="token punctuation">,</span> proto<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isType</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> <span class="token string">&quot;Array&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 对数组做特殊处理</span>
      child <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isType</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> <span class="token string">&quot;RegExp&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 对正则对象做特殊处理</span>
      child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span>source<span class="token punctuation">,</span> <span class="token function">getRegExp</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>lastIndex<span class="token punctuation">)</span> child<span class="token punctuation">.</span>lastIndex <span class="token operator">=</span> parent<span class="token punctuation">.</span>lastIndex<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isType</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> <span class="token string">&quot;Date&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 对Date对象做特殊处理</span>
      child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 处理对象原型</span>
      proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 利用Object.create切断原型链</span>
      child <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>proto<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 处理循环引用</span>
    <span class="token keyword">const</span> index <span class="token operator">=</span> parents<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象</span>
      <span class="token keyword">return</span> children<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    parents<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">in</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 递归</span>
      child<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">_clone</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> child<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">_clone</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>局限性:</p> <ol><li>一些特殊情况没有处理: 例如Buffer对象、Promise、Set、Map</li> <li>另外对于确保没有循环引用的对象，我们可以省去对循环引用的特殊处理，因为这很消耗时间</li></ol> <h2 id="实现订阅发布模式"><a href="#实现订阅发布模式" class="header-anchor">#</a> 实现订阅发布模式</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">EventEmitter</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_events <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_events <span class="token operator">||</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 储存事件/回调键值对</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_maxListeners <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_maxListeners <span class="token operator">||</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 设立监听上限</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 触发名为type的事件</span>
<span class="token class-name">EventEmitter</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">emit</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> handler<span class="token punctuation">;</span>
  handler <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果是一个数组说明有多个监听者,需要依次此触发里面的函数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> handler<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        handler<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        handler<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 单个函数的情况我们直接触发即可</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">handler</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">handler</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 监听名为type的事件</span>
<span class="token class-name">EventEmitter</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">addListener</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取对应事件名称的函数清单</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>handler <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> handler <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果handler是函数说明只有一个监听者</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> <span class="token punctuation">[</span>handler<span class="token punctuation">,</span> fn<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 多个监听者我们需要用数组储存</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    handler<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 已经有多个监听者,那么直接往数组里push函数即可</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token class-name">EventEmitter</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">removeListener</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取对应事件名称的函数清单</span>

  <span class="token comment">// 如果是函数,说明只被监听了一次</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>handler <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> handler <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> position<span class="token punctuation">;</span>
    <span class="token comment">// 如果handler是数组,说明被监听多次要找到对应的函数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> handler<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>handler<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        position <span class="token operator">=</span> i<span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        position <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 如果找到匹配的函数,从数组中清除</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 找到数组对应的位置,直接清除此回调</span>
      handler<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 如果清除后只有一个函数,那么取消数组,以函数形式保存</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>handler<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> handler<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="实现promise"><a href="#实现promise" class="header-anchor">#</a> 实现Promise</h2> <p><a href="https://github.com/nmsn/demo/blob/master/Promise.js" target="_blank" rel="noopener noreferrer">手动实现 Promise 代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="内存管理"><a href="#内存管理" class="header-anchor">#</a> 内存管理</h2> <h3 id="内存回收"><a href="#内存回收" class="header-anchor">#</a> 内存回收</h3> <p>V8的垃圾回收策略基于分代回收机制，该机制又基于世代假说,该假说有两个特点:</p> <ul><li>大部分新生对象倾向于早死</li> <li>不死的对象，会活得更久</li></ul> <p>基于这个理论，现代垃圾回收算法根据对象的存活时间将内存进行了分代，并对不同分代的内存采用不同的高效算法进行垃圾回收</p> <h3 id="v8的内存分代"><a href="#v8的内存分代" class="header-anchor">#</a> V8的内存分代</h3> <p>在V8中，将内存分为了新生代（new space）和老生代（old space）。它们特点如下：</p> <ul><li>新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象。</li> <li>老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象。</li></ul> <h3 id="scavenge-算法"><a href="#scavenge-算法" class="header-anchor">#</a> Scavenge 算法</h3> <p>Scavenge 算法的缺点是，它的算法机制决定了只能利用一半的内存空间。但是新生代中的对象生存周期短、存活对象少，进行对象复制的成本不是很高，因而非常适合这种场景。</p> <p>新生代中的对象主要通过 Scavenge 算法进行垃圾回收。Scavenge 的具体实现，主要采用了Cheney算法。</p> <p><img src="/assets/img/v8_cache.b8835718.png" alt="v8_cache"></p> <p>Cheney算法采用复制的方式进行垃圾回收。它将堆内存一分为二，每一部分空间称为 semispace。这两个空间，只有一个空间处于使用中，另一个则处于闲置。使用中的 semispace 称为 「From 空间」，闲置的 semispace 称为 「To 空间」。</p> <p>过程如下：</p> <ul><li>从 From 空间分配对象，若 semispace 被分配满，则执行 Scavenge 算法进行垃圾回收。</li> <li>检查 From 空间的存活对象，若对象存活，则检查对象是否符合晋升条件，若符合条件则晋升到老生代，否则将对象从 From 空间复制到 To 空间。</li> <li>若对象不存活，则释放不存活对象的空间。</li> <li>完成复制后，将 From 空间与 To 空间进行角色翻转（flip）。</li></ul> <h3 id="对象晋升"><a href="#对象晋升" class="header-anchor">#</a> 对象晋升</h3> <ul><li>对象是否经历过Scavenge回收。对象从 From 空间复制 To 空间时，会检查对象的内存地址来判断对象是否已经经过一次Scavenge回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。</li> <li>To 空间的内存使用占比是否超过限制。当对象从From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置为25%的比例的原因是，当完成 Scavenge 回收后，To 空间将翻转成From 空间，继续进行对象内存的分配。若占比过大，将影响后续内存分配。</li></ul> <p>对象晋升到老生代后，将接受新的垃圾回收算法处理。下图为Scavenge算法中，对象晋升流程图。</p> <p><img src="/assets/img/v8_cache2.7d503b3c.png" alt="v8_cache"></p> <h3 id="mark-sweep-mark-compact"><a href="#mark-sweep-mark-compact" class="header-anchor">#</a> Mark-Sweep &amp; Mark-Compact</h3> <p>老生代中的对象有两个特点，第一是存活对象多，第二个存活时间长。若在老生代中使用 Scavenge 算法进行垃圾回收，将会导致复制存活对象的效率不高，且还会浪费一半的空间。因而，V8在老生代采用Mark-Sweep 和 Mark-Compact 算法进行垃圾回收。</p> <p>Mark-Sweep，是标记清除的意思。它主要分为标记和清除两个阶段。</p> <ul><li>标记阶段，它将遍历堆中所有对象，并对存活的对象进行标记；
清除阶段，对未标记对象的空间进行回收。</li> <li>与 Scavenge 算法不同，Mark-Sweep 不会对内存一分为二，因此不会浪费空间。但是，经历过一次 Mark-Sweep 之后，内存的空间将会变得不连续，这样会对后续内存分配造成问题。比如，当需要分配一个比较大的对象时，没有任何一个碎片内支持分配，这将提前触发一次垃圾回收，尽管这次垃圾回收是没有必要的。</li></ul> <p>为了解决内存碎片的问题，提高对内存的利用，引入了 Mark-Compact （标记整理）算法。Mark-Compact 是在 Mark-Sweep 算法上进行了改进，标记阶段与Mark-Sweep相同，但是对未标记的对象处理方式不同。与Mark-Sweep是对未标记的对象立即进行回收，Mark-Compact则是将存活的对象移动到一边，然后再清理端边界外的内存。</p> <p>由于Mark-Compact需要移动对象，所以执行速度上，比Mark-Sweep要慢。所以，V8主要使用Mark-Sweep算法，然后在当空间内存分配不足时，采用Mark-Compact算法。</p> <h3 id="incremental-marking-增量标记"><a href="#incremental-marking-增量标记" class="header-anchor">#</a> Incremental Marking（增量标记）</h3> <p>在新生代中，由于存活对象少，垃圾回收效率高，全停顿时间短，造成的影响小。但是老生代中，存活对象多，垃圾回收时间长，全停顿造成的影响大。为了减少全停顿的时间，V8对标记进行了优化，将一次停顿进行的标记过程，分成了很多小步。每执行完一小步就让应用逻辑执行一会儿，这样交替多次后完成标记。如下图所示：</p> <p><img src="/assets/img/v8_cache3.d42805a7.png" alt="v8_cache"></p> <p>长时间的GC，会导致应用暂停和无响应，将会导致糟糕的用户体验。从2011年起，v8就将「全暂停」标记换成了增量标记。改进后的标记方式，最大停顿时间减少到原来的1/6。</p> <h3 id="弱引用"><a href="#弱引用" class="header-anchor">#</a> 弱引用</h3> <p>前面说过，及时清除引用非常重要。但是，你不可能记得那么多，有时候一疏忽就忘了，所以才有那么多内存泄漏。</p> <p>最好能有一种方法，在新建引用的时候就声明，哪些引用必须手动清除，哪些引用可以忽略不计，当其他引用消失以后，垃圾回收机制就可以释放内存。这样就能大大减轻程序员的负担，你只要清除主要引用就可以了。</p> <p>ES6 考虑到了这一点，推出了两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个&quot;Weak&quot;，表示这是弱引用。</p> <h3 id="weakmap-和-weakset"><a href="#weakmap-和-weakset" class="header-anchor">#</a> WeakMap 和 WeakSet</h3> <h4 id="weakmap"><a href="#weakmap" class="header-anchor">#</a> WeakMap</h4> <p>WeakMap 和 Map 的第一个不同点就是，WeakMap 的键必须是对象，不能是原始值：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> weakMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

weakMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">&quot;ok&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 正常工作（以对象作为键）</span>

<span class="token comment">// 不能使用字符串作为键</span>
weakMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Whoops&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error，因为 &quot;test&quot; 不是一个对象</span>
</code></pre></div><p>现在，如果我们在 weakMap 中使用一个对象作为键，并且没有其他对这个对象的引用 —— 该对象将会被从内存（和map）中自动清除。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> john <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;John&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> weakMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
weakMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>john<span class="token punctuation">,</span> <span class="token string">&quot;...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

john <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 覆盖引用</span>

<span class="token comment">// john 被从内存中删除了！</span>
</code></pre></div><p>与上面常规的 Map 的例子相比，现在如果 john 仅仅是作为 WeakMap 的键而存在 —— 它将会被从 map（和内存）中自动删除。</p> <p>WeakMap 不支持迭代以及 keys()，values() 和 entries() 方法。所以没有办法获取 WeakMap 的所有键或值。</p> <p>WeakMap 只有以下的方法：</p> <ul><li>weakMap.get(key)</li> <li>weakMap.set(key, value)</li> <li>weakMap.delete(key)</li> <li>weakMap.has(key)</li></ul> <p>为什么会有这种限制呢？这是技术的原因。如果一个对象丢失了其它所有引用（就像上面示例中的 john），那么它就会被垃圾回收机制自动回收。但是在从技术的角度并不能准确知道 何时会被回收。</p> <p>这些都是由 JavaScript 引擎决定的。JavaScript 引擎可能会选择立即执行内存清理，如果现在正在发生很多删除操作，那么 JavaScript 引擎可能就会选择等一等，稍后再进行内存清理。因此，从技术上讲，WeakMap 的当前元素的数量是未知的。JavaScript 引擎可能清理了其中的垃圾，可能没清理，也可能清理了一部分。因此，暂不支持访问 WeakMap 的所有键/值的方法。</p> <h4 id="weakset"><a href="#weakset" class="header-anchor">#</a> WeakSet</h4> <p>WeakSet 的表现类似：</p> <ul><li>与 Set 类似，但是我们只能向 WeakSet 添加对象（而不能是原始值）。</li> <li>对象只有在其它某个（些）地方能被访问的时候，才能留在 set 中。</li> <li>跟 Set 一样，WeakSet 支持 add，has 和 delete 方法，但不支持 size 和 keys()，并且不可迭代。</li></ul> <p>变“弱（weak）”的同时，它也可以作为额外的存储空间。但并非针对任意数据，而是针对“是/否”的事实。WeakSet 的元素可能代表着有关该对象的某些信息。</p> <p>例如，我们可以将用户添加到 WeakSet 中，以追踪访问过我们网站的用户：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> visitedSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> john <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;John&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> pete <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;Pete&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> mary <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;Mary&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

visitedSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>john<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// John 访问了我们</span>
visitedSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>pete<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 然后是 Pete</span>
visitedSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>john<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// John 再次访问</span>

<span class="token comment">// visitedSet 现在有两个用户了</span>

<span class="token comment">// 检查 John 是否来访过？</span>
<span class="token function">alert</span><span class="token punctuation">(</span>visitedSet<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>john<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token comment">// 检查 Mary 是否来访过？</span>
<span class="token function">alert</span><span class="token punctuation">(</span>visitedSet<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>mary<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>

john <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

<span class="token comment">// visitedSet 将被自动清理</span>
</code></pre></div><p>WeakMap 和 WeakSet 最明显的局限性就是不能迭代，并且无法获取所有当前内容。那样可能会造成不便，但是并不会阻止 WeakMap/WeakSet 完成其主要工作 — 成为在其它地方管理/存储“额外”的对象数据。</p> <h4 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h4> <p>WeakMap 是类似于 Map 的集合，它仅允许对象作为键，并且一旦通过其他方式无法访问它们，便会将它们与其关联值一同删除。</p> <p>WeakSet 是类似于 Set 的集合，它仅存储对象，并且一旦通过其他方式无法访问它们，便会将其删除。</p> <p>它们都不支持引用所有键或其计数的方法和属性。仅允许单个操作。</p> <p>WeakMap 和 WeakSet 被用作“主要”对象存储之外的“辅助”数据结构。一旦将对象从主存储器中删除，如果该对象仅被用作 WeakMap 或 WeakSet 的键，那么它将被自动清除。</p> <h3 id="参考文献"><a href="#参考文献" class="header-anchor">#</a> 参考文献</h3> <ul><li>JavaScript内存管理：<a href="https://www.cxymsg.com/guide/memory.html#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6" target="_blank" rel="noopener noreferrer">https://www.cxymsg.com/guide/memory.html#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>JavaScript 内存泄漏教程：<a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html" target="_blank" rel="noopener noreferrer">http://www.ruanyifeng.com/blog/2017/04/memory-leak.html<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>
-WeakMap and WeakSet（弱映射和弱集合）: <a href="https://zh.javascript.info/weakmap-weakset" target="_blank" rel="noopener noreferrer">https://zh.javascript.info/weakmap-weakset<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h2 id="前端路由的实现"><a href="#前端路由的实现" class="header-anchor">#</a> 前端路由的实现</h2> <h3 id="h5-history-api"><a href="#h5-history-api" class="header-anchor">#</a> H5 History API</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Routers</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>routes <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// 在初始化时监听popstate事件</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_bindPopState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 初始化路由</span>
  <span class="token function">init</span><span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    history<span class="token punctuation">.</span><span class="token function">replaceState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>path<span class="token operator">:</span> path<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>routes<span class="token punctuation">[</span>path<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>routes<span class="token punctuation">[</span>path<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 将路径和对应回调函数加入hashMap储存</span>
  <span class="token function">route</span><span class="token punctuation">(</span><span class="token parameter">path<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>routes<span class="token punctuation">[</span>path<span class="token punctuation">]</span> <span class="token operator">=</span> callback <span class="token operator">||</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 触发路由对应回调</span>
  <span class="token function">go</span><span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    history<span class="token punctuation">.</span><span class="token function">pushState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>path<span class="token operator">:</span> path<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>routes<span class="token punctuation">[</span>path<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>routes<span class="token punctuation">[</span>path<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 监听popstate事件</span>
  <span class="token function">_bindPopState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'popstate'</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> path <span class="token operator">=</span> e<span class="token punctuation">.</span>state <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span>state<span class="token punctuation">.</span>path<span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>routes<span class="token punctuation">[</span>path<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>routes<span class="token punctuation">[</span>path<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="offset-client-scroll"><a href="#offset-client-scroll" class="header-anchor">#</a> offset/client/scroll</h2> <p><img src="/assets/img/js_wh_tl.b0af9bc3.png" alt="宽高属性"></p> <h2 id="立即调用函数表达式-iife-立即执行函数"><a href="#立即调用函数表达式-iife-立即执行函数" class="header-anchor">#</a> 立即调用函数表达式（IIFE）/立即执行函数</h2> <h3 id="标准形式的立即执行函数"><a href="#标准形式的立即执行函数" class="header-anchor">#</a> 标准形式的立即执行函数</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><p>JavaScript解析器必须能够轻易区分函数声明和函数表达式之间的区别。</p> <p>如果去掉包裹函数表达式的括号，把立即调用作为一个独立语句function() {}(3)，JavaScript开始解析时便会结束，因为这个独立语句以function开头，那么解析器就会认为它在处理一个函数声明。</p> <p>每个函数声明必须有一个名字(然而这里并没有指定名字)，所以程序执行到这里会报错。为了 避免错误，函数表达式要放在括号内，为JavaScript解析器指明它正在处理一个函数表达式而不是语句。</p></li> <li><p>还有一种相对简单的替代方案(function(){}(3))也能达到相同目标(然而这种方案有些 奇怪，故不常使用)。把立即函数的定义和调用都放在括号内，同样可以为JavaScript 解析器指明它正在处理函数表达式。</p></li></ul> <h3 id="特殊形式的立即执行函数"><a href="#特殊形式的立即执行函数" class="header-anchor">#</a> 特殊形式的立即执行函数</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">+</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">-</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">!</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">~</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>不同于用加括号的方式区分函数表达式和函数声明，这里我们使用一元操作符+、-、!和~。这种做法也是用于向JavaScript引擎指明它处理的是表达式，而不是语句。从计算机的角度来讲，注意应用一元操作符得到的结果没有存储到任何地方并不重要，只有调用 IIFE 才重要。</li></ul> <h3 id="isnan-与-number-isnan-的区别"><a href="#isnan-与-number-isnan-的区别" class="header-anchor">#</a> isNaN 与 Number.isNaN 的区别</h3> <p>Number.isNaN() 方法确定传递的值是否为 NaN，并且检查其类型是否为 Number。它是原来的全局 isNaN() 的更稳妥的版本。</p> <p>在 JavaScript 中，NaN 最特殊的地方就是，我们不能使用相等运算符（== 和 ===）来判断一个值是否是 NaN，因为 NaN == NaN 和 NaN === NaN 都会返回 false。因此，必须要有一个判断值是否是 NaN 的方法。</p> <p>和全局函数 isNaN() 相比，Number.isNaN() 不会自行将参数转换成数字，只有在参数是值为 NaN 的数字时，才会返回 true。</p> <h3 id="和-object-is"><a href="#和-object-is" class="header-anchor">#</a> === 和 Object.is</h3> <p>Object.is 与 === 行为基本一致，不同点在于</p> <ul><li>+0 不等于 -0</li> <li>NaN 等于自身</li></ul> <h3 id="encodeuri-与-encodeuricomponent-的区别"><a href="#encodeuri-与-encodeuricomponent-的区别" class="header-anchor">#</a> encodeURI 与 encodeURIComponent 的区别</h3> <ul><li><p>相同点：都可以对url进行一个编码</p></li> <li><p>区别：encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码</p></li> <li><p>encodeURI：适用于url跳转时</p></li> <li><p>encodeURIComponent：适用于url作为参数传递时</p></li> <li><p>注意：当url作为参数传递时如果没有用encodeURIComponent进行编码，往往会造成传递时url中的特殊字符丢失</p></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">2021/4/27 下午5:56:28</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/interviewQuestions/CSS.html" class="prev">
        CSS
      </a></span> <span class="next"><a href="/interviewQuestions/Network.html">
        网络
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.139693ee.js" defer></script><script src="/assets/js/2.4a609977.js" defer></script><script src="/assets/js/8.6f768000.js" defer></script>
  </body>
</html>
